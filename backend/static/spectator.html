<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PRS — Spectator Leaderboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Stylesheets -->
  <!-- NOTE: served by FastAPI StaticFiles at /ui -->
  <link rel="stylesheet" href="/ui/css/base.css?v=3">
  <link rel="stylesheet" href="/ui/css/spectator.css?v=3">

  <!-- Optional shared helpers. This page works fine even if base.js is missing. -->
  <script src="/ui/js/base.js?v=3" defer></script>
</head>
<body>
  <!-- ===================== HEADER ===================== -->
  <header>
    <div class="logo">
      <!-- Path assumes /ui/img/PRS_Logo.svg exists -->
      <img src="/ui/img/PRS_Logo.svg" alt="PRS Logo" />
    </div>
    <div class="title">Live Timing — Spectator</div>
    <div class="raceclock-wrap">
      <div class="raceclock-label">Race&nbsp;Clock</div>
      <div class="race-type" id="raceType" aria-label="Race type"></div>
      <div class="pill pill-xl" id="raceClock" aria-live="polite" aria-label="Race clock">-:--:--</div>
    </div>
  </header>

  <!-- ====================== MAIN ====================== -->
  <main>
    <!-- Live flag/banner (colors/states styled in spectator.css) -->
    <div id="flagBanner" class="flag hidden" aria-live="polite">
      <div class="flag__icon" id="flagIcon" aria-hidden="true"></div>
      <div class="flag__label" id="flagLabel">Pre-Grid</div>
    </div>

    <!-- Leaderboard card -->
    <section class="card" aria-label="Leaderboard">
      <h2>Leaderboard</h2>
      <div class="table" role="table" aria-label="Race standings">
        <div class="thead" role="row">
          <div role="columnheader">Position</div>
          <div role="columnheader">Car #</div>
          <div role="columnheader">Team</div>
          <div role="columnheader" class="right">Laps</div>
          <div role="columnheader" class="right">Last Lap</div>
          <div role="columnheader" class="right">Best Lap</div>
        </div>
        <div class="rows" id="rows" role="rowgroup"></div>
      </div>
    </section>
  </main>

  <!-- ===================== FOOTER ===================== -->
  <footer>
    <div class="footer-left">
      <div class="status-dot" id="netDot" title="Network status"></div>
      <div id="netMsg">Connecting…</div>
    </div>

    <!-- Centered wall clock (local time) -->
    <div id="wallClock" class="pill" aria-label="Local time">--:--:--</div>

    <!-- Simulator Active Text -->
    <span id="simBadge" class="sim-badge" hidden>SIMULATOR&nbsp;ACTIVE</span>

    <div class="footer-right">
      <div>API: <a class="link" id="apiLink" href="#" target="_blank" rel="noopener">/laps</a></div>
    </div>
  </footer>

  <!-- =================== PAGE SCRIPT =================== -->
  <script>
    // ---------- Minimal helpers (work even if base.js is absent) ----------
    const $  = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => [...root.querySelectorAll(sel)];

    function fmtRaceClock(ms) {
      if (ms == null || isNaN(ms)) return '-:--:--';
      const total = Math.max(0, Math.floor(ms / 1000));
      const mm = Math.floor(total / 60);
      const ss = String(total % 60).padStart(2, '0');
      return `${mm}:${ss}`;
    }

    function fmtHMS(ms) {
      const total = Math.max(0, Math.floor(ms / 1000));
      const h = Math.floor(total / 3600);
      const m = Math.floor((total % 3600) / 60);
      const s = total % 60;
      return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function fmtLapSeconds(s) {
      return (s == null || isNaN(s)) ? '—' : Number(s).toFixed(3);
    }
    function startWallClock(selector) {
      const target = $(selector);
      if (!target) return;
      const tick = () => {
        const d = new Date();
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        const ss = String(d.getSeconds()).padStart(2, '0');
        target.textContent = `${hh}:${mm}:${ss}`;
      };
      tick();
      setInterval(tick, 1000);
    }

    function setSimBadge(active, label) {
      const el = document.getElementById('simBadge');
      if (!el) return;
      if (active) {
        el.hidden = false;
        el.classList.add('on');
        if (label) el.textContent = label;
      } else {
        el.hidden = true;
        el.classList.remove('on');
      }
    }

    // Race type label section
    function setRaceTypeLabel(t) {
      const el = document.getElementById('raceType');
      if (!el) return;
      const key = String(t || '').trim().toLowerCase();
      const pretty = ({
        'sprint': 'Sprint Race',
        'sprint race': 'Sprint Race',
        'endurance': 'Endurance',
        'free': 'Free Play',
        'freeplay': 'Free Play',
        'practice': 'Free Play',
        'qual': 'Qualifying',
        'qualify': 'Qualifying',
        'qualifying': 'Qualifying',
        'relay': 'Relay'
      })[key] || (key ? key.charAt(0).toUpperCase() + key.slice(1) : '');
      el.textContent = pretty;
    }
  
    // --- Client clock smoother (500ms local tick anchored to server state)
    let __clockSyncMs = null;      // last clock_ms we got from the server
    let __clockSyncAt = 0;         // performance.now() when we received it
    let __clockRunning = false;    // whether the server says the race is running

    function tickRaceClock() {
      const el = document.getElementById('raceClock');
      if (!el) return;

      if (__clockSyncMs == null) {
        el.textContent = '-:--:--';
        return;
      }

      let ms = __clockSyncMs;
      if (__clockRunning) {
        ms += (performance.now() - __clockSyncAt);
      }
      el.textContent = fmtHMS(ms);   // you already have fmtHMS(h:mm:ss)
    }

    // run at 500ms
    setInterval(tickRaceClock, 500);

    // Prefer helpers from base.js if present
    const PRS = window.PRS || {};
    const startClock = (PRS.startWallClock || startWallClock);

    // ---------- Runtime configuration ----------
    const qp = new URLSearchParams(location.search);
    const raceId = Number(qp.get('race_id') || 1);
    const POLL_MS = 1000;

    const apiUrl = (path) => `${path}${path.includes('?') ? '&' : '?'}race_id=${raceId}`;
    $("#apiLink").href = apiUrl("/laps?limit=5");
    $("#apiLink").textContent = "/laps";

    // ---------- Local state ----------
    let lastOrder = [];           // previous row order for delta arrows
    let lastRowsPainted = null;   // last rendered logical rows (for resize)

    // Derive a stable pseudo car number from tag until real numbers are stored.
    const carNumFromTag = (tag) => ((Number(String(tag).replace(/\D/g, "")) % 900) + 100);

    // ---------- Flag banner rendering ----------
    function renderFlag(flag) {
      const host = $('#flagBanner'), icon = $('#flagIcon'), lbl = $('#flagLabel');
      if (!host || !icon || !lbl) return;

      const fRaw = String(flag || '').toLowerCase();
      if (!fRaw) { host.className = 'flag hidden'; host.dataset.currentFlag = ''; return; }

      const prev = host.dataset.currentFlag || '';   // <-- read BEFORE we change it
      const f = fRaw;

      const textMap = {
        pre       : 'Pre-Grid',
        green     : 'Green Flag',
        yellow    : 'Caution — Yellow',
        red       : 'Race Stopped — Red',
        blue      : 'Blue Flag',
        white     : 'Final Lap',
        checkered : 'Checkered — Finish'
      };

      // Apply base classes first
      host.className = `flag flag--${f}`;

      // Pulse these states
      const pulsing = new Set(['yellow','red','blue','checkered']);
      if (pulsing.has(f)) host.classList.add('is-pulsing'); else host.classList.remove('is-pulsing');

      // One-shot flash when SWITCHING into green
      if (f === 'green' && prev !== 'green') {
        host.classList.remove('flash');  // reset if lingering
        void host.offsetWidth;           // force reflow so animation can restart
        host.classList.add('flash');
        host.addEventListener('animationend', (e) => {
          if (e.animationName === 'greenFlash') host.classList.remove('flash');
        }, { once: true });
      }

      // Icon + label
      const fillColor = {
        pre:'#64748b', green:'#22c55e', yellow:'#facc15', red:'#ef4444',
        blue:'#3b82f6', white:'#e2e8f0', checkered:'#d1d5db'
      }[f] || '#e5e7eb';

      icon.innerHTML = `
        <svg width="22" height="22" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <rect x="1" y="1" width="20" height="20" rx="3" fill="${fillColor}" opacity="0.9"/>
          <path d="M3 19 L19 3" stroke="#0b0f13" stroke-width="3" stroke-linecap="round" />
        </svg>`;
      lbl.textContent = textMap[f] || 'Flag';

      // NOW record current state (so we detect the next transition)
      host.dataset.currentFlag = f;
    }


    // ---------- Race clock rendering ----------
    function renderClock(clock_ms) {
      $('#raceClock').textContent = (clock_ms == null ? '-:--:--' : fmtHMS(clock_ms));
    }

    // ---------- Leaderboard rendering with FLIP animation ----------
    function renderRows(rows) {
      lastRowsPainted = rows;
      const container = $('#rows');
      const existing = new Map([...container.children].map(el => [Number(el.dataset.tag), el]));

      const newOrder = rows.map(r => r.tag);
      const deltas = new Map();
      if (lastOrder.length) {
        const posPrev = new Map(lastOrder.map((t, i) => [t, i]));
        for (let i = 0; i < newOrder.length; i++) {
          const tag = newOrder[i];
          if (!posPrev.has(tag)) { deltas.set(tag, 0); continue; }
          const diff = posPrev.get(tag) - i;
          deltas.set(tag, diff === 0 ? 0 : (diff > 0 ? +1 : -1));
        }
      }
      lastOrder = newOrder;

      // 1) Measure first positions
      const firstPos = new Map();
      for (const el of container.children) firstPos.set(Number(el.dataset.tag), el.getBoundingClientRect().top);

      // 2) Ensure elements exist and arrange in final order
      for (const r of rows) {
        let el = existing.get(r.tag);
        if (!el) {
          el = document.createElement('div');
          el.className = 'row';
          el.dataset.tag = r.tag;
          el.innerHTML = `
            <div class="pos"></div>
            <div class="right car"></div>
            <div class="name"></div>
            <div class="laps"></div>
            <div class="right last"></div>
            <div class="right best"></div>`;
          container.appendChild(el);
          existing.set(r.tag, el);
        }
      }
      for (const r of rows) container.appendChild(existing.get(r.tag));

      // 3) Invert & play + populate cells
      for (const r of rows) {
        const el = existing.get(r.tag);
        const lastTop  = el.getBoundingClientRect().top;
        const firstTop = firstPos.get(r.tag) ?? lastTop;
        const dy = firstTop - lastTop;

        el.style.transition = 'transform 0s';
        el.style.transform  = `translateY(${dy}px)`;
        requestAnimationFrame(() => {
          el.style.transition = 'transform 800ms cubic-bezier(0.2,0,0,1)';
          el.style.transform  = 'translateY(0)';
        });

        // Fill cells
        el.querySelector('.pos').textContent  = String(rows.indexOf(r) + 1);
        el.querySelector('.car').textContent  = r.car ?? carNumFromTag(r.tag);
        el.querySelector('.name').textContent = r.team || r.driver || `Tag ${r.tag}`;
        el.querySelector('.laps').textContent = r.laps ?? 0;
        el.querySelector('.last').textContent = fmtLapSeconds(r.last);

        // --- Personal Best (PB) flash logic ---
        const bestCell = el.querySelector('.best');
        const prevBest = el._bestLap;
        const prevLaps = el._laps || 0;
        const curBest  = r.best;
        const curLaps  = r.laps ?? 0;

        bestCell.textContent = fmtLapSeconds(curBest);

        // If best improved and we already had at least 1 completed lap, flash PB
        if (prevBest != null && curBest != null && curBest < prevBest && curLaps >= 1) {
          bestCell.classList.add('pb-live');
          // Keep PB highlight until this kart completes the *next* lap
          el._pbClearAtLaps = curLaps + 1;
        }

        // Clear PB highlight when the next lap arrives
        if (el._pbClearAtLaps != null && curLaps >= el._pbClearAtLaps) {
          bestCell.classList.remove('pb-live');
          el._pbClearAtLaps = null;
        }

        el._bestLap = (curBest != null ? curBest : null);
        el._laps    = curLaps;

        // Position delta bubble
        const d = (deltas.get(r.tag) || 0);
        const bubble = el._bubble || (() => {
          const b = document.createElement('span');
          b.className = 'delta';
          el.querySelector('.pos').appendChild(b);
          el._bubble = b;
          return b;
        })();
        if (d > 0)      { bubble.textContent = '▲'; bubble.className = 'delta up';   bubble.style.opacity = '0.95'; }
        else if (d < 0) { bubble.textContent = '▼'; bubble.className = 'delta down'; bubble.style.opacity = '0.95'; }
        else            { bubble.textContent = '';  bubble.style.opacity = '0'; }
      }

      // Remove vanished rows
      for (const el of [...container.children]) {
        const tag = Number(el.dataset.tag);
        if (!rows.find(r => r.tag === tag)) el.remove();
      }
    }

    // ---------- API fetchers ----------
    async function fetchRaceState() {
      const r = await fetch(apiUrl('/race/state'), { cache: 'no-store' });
      if (!r.ok) throw new Error('race_state failed');
      return r.json(); // { flag, clock_ms, standings?, ... }
    }
    async function fetchLeaderboard() {
      const r = await fetch(apiUrl('/laps'), { cache: 'no-store' });
      if (!r.ok) throw new Error('laps failed');
      return r.json(); // { rows: [{ tag, team, driver, laps, last, best }], ... }
    }

      // ---------- Polling loop ----------
     async function poll() {
      try {
        // Leaderboard rows
        const lapData = await fetchLeaderboard();
        const rows = Array.isArray(lapData.rows) ? lapData.rows.map(rec => ({
          tag: Number(rec.tag),
          team: rec.team || null,
          driver: rec.driver || null,
          laps: rec.laps ?? 0,
          last: rec.last ?? null,
          best: rec.best ?? null,
          car: null,
          lastT: null
        })) : [];

        renderRows(rows);
        $('#netDot').style.background = 'var(--ok)';
        $('#netMsg').textContent = `OK — ${rows.length} entries`;
      } catch (e) {
        $('#netDot').style.background = 'var(--error)';
        $('#netMsg').textContent = 'Disconnected — retrying…';
        console.error(e);
      }

      // Race status (non-fatal to table)
      const qp = new URLSearchParams(location.search);
      const urlSimParam = qp.get('sim');
      const urlFeed = qp.get('feed');

      // URL overrides
      const urlSimForceOn  = urlSimParam === '1' || urlSimParam === 'true';
      const urlSimForceOff = urlSimParam === '0' || urlSimParam === 'false';

      try {
        const s = await fetchRaceState();

        // Base detection from server
        let simActive =
          s.sim === true ||
          s.is_sim === true ||
          s.source === 'sim' ||
          s.feed === 'sim' ||
          s.race_type === 'sim';

        // URL explicit overrides win
        if (urlSimForceOn)  simActive = true;
        if (urlSimForceOff) simActive = false;

        const simLabel = s.sim_label || 'SIMULATOR ACTIVE';
        setSimBadge(simActive, simLabel);   // <-- always called; hides when false

        // Race type label (API or ?type= fallback)
        setRaceTypeLabel(s.race_type || s.raceType || s.type || qp.get('type'));

        // Stay PRE until backend actually provides a clock
        const nextFlag = (typeof s.clock_ms === 'number') ? (s.flag || 'green') : 'pre';
        renderFlag(nextFlag);

        // Anchor the local 500ms race-clock tick to server state
        if (typeof s.clock_ms === 'number') {
          __clockSyncMs = s.clock_ms;
          __clockSyncAt = performance.now();
        } else {
          __clockSyncMs = null; // no clock yet → show -:--:--
        }
        __clockRunning = !!(s.running ?? s.clock_running ?? s.is_running);

        // render immediately; interval keeps it fresh
        tickRaceClock();

      } catch (e) {
        // On error, respect explicit URL override; otherwise hide the badge
        if (urlSimForceOn)  setSimBadge(true,  'SIMULATOR ACTIVE');
        else                setSimBadge(false, 'SIMULATOR ACTIVE');
      }
    } // <-- this brace was missing

    // ---------- Boot ----------
    window.addEventListener('DOMContentLoaded', () => {
      startWallClock('#wallClock');   // fix: this was startClock
      renderFlag('pre');              // initial state
      poll();                         // first fetch
      setInterval(poll, POLL_MS);     // regular polling
    });

    // Keep clock pill readable even if race_state request hiccups
    setInterval(() => {
      const el = document.getElementById('raceClock');
      const text = el ? el.textContent : '';
      if (!text.trim()) el.textContent = '-:--:--';
    }, 2000);
  </script>
</body>
</html>
