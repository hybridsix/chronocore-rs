from __future__ import annotations

"""
ChronoCore RS - backend/server.py (drop-in)
------------------------------------------
This version keeps the original public surface but fixes the following:
1) /engine/entrant/assign_tag
   - Idempotent: assigning the same tag to the same entrant returns 200 OK.
   - Conflict checks only consider ENABLED entrants and exclude the incumbent.
   - On change, writes through to SQLite so DB and Engine stay in sync.

2) /engine/load
   - Rejects malformed payloads with clean 400s (no crashes, no int(None)).
   - Coerces entrant ids to int *before* any mapping.

3) Health probes
   - /healthz: liveness (no DB access).
   - /readyz: readiness (touches SQLite to confirm schema presence).

4) DB path
   - Sourced via config_loader.get_db_path(), which defaults to backend/db/laps.sqlite
     unless overridden in config/app.yaml.
"""

import asyncio
import datetime
import json
import logging
import time
import sqlite3
from collections import deque
from pathlib import Path
from typing import Any, Dict, List, Optional
import yaml

import aiosqlite
from fastapi import FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field, ValidationError, field_validator

from .db_schema import ensure_schema, tag_conflicts
from .config_loader import get_db_path

log = logging.getLogger("uvicorn.error")

# ------------------------------------------------------------
# FastAPI app bootstrap
# ------------------------------------------------------------
app = FastAPI(title="CCRS Backend", version="0.2.1")

# ------------------------------------------------------------
# Simple scan bus state
# ------------------------------------------------------------
last_tag: dict[str, object] = {"tag": None, "seen_at": None}
_listeners: list[asyncio.Queue[str]] = []   # SSE subscribers

def publish_tag(tag: str) -> float:
    """Push a tag into the bus and wake SSE listeners. Returns seen_at timestamp."""
    ts = time.time()
    last_tag["tag"] = str(tag)
    last_tag["seen_at"] = ts
    # Wake any waiting SSE clients
    for q in list(_listeners):
        try:
            q.put_nowait(str(tag))
        except Exception:
            pass
    return ts


# ------------------------------------------------------------
# CORS: permissive for development. Tighten for production.
#------------------------------------------------------------
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Try <repo>/ui first; fall back to <repo>/backend/static
PROJECT_ROOT = Path(__file__).resolve().parents[1]  # <repo> when server.py is in backend/
UI_DIR = PROJECT_ROOT / "ui"
MODES_PATH = (PROJECT_ROOT / "config" / "race_modes.yaml").resolve()
#STATIC_DIR = UI_DIR if UI_DIR.exists() else Path(__file__).resolve().parent / "static"
#app.mount("/ui", StaticFiles(directory=STATIC_DIR, html=True), name="ui")
STATIC_DIR = Path(__file__).resolve().parent.parent / "ui"   # => project_root/ui
app.mount("/ui", StaticFiles(directory=STATIC_DIR, html=True), name="ui")

log.info("Serving UI from: %s", STATIC_DIR)  # sanity print at startup



# Resolve DB path from config and ensure schema on boot.
DB_PATH = get_db_path()
ensure_schema(DB_PATH, recreate=False, include_passes=True)

# ------------------------------------------------------------
# Minimal "Engine" adapter used by these endpoints
# ------------------------------------------------------------
class _Engine:
    """
    Very small in-memory session mirror the operator UI interacts with.
    Your real runtime engine can replace this; keep method names the same.
    """
    def __init__(self) -> None:
        self._entrants: Dict[int, Dict[str, Any]] = {}

    def load(self, entrants: List[Dict[str, Any]]) -> Dict[str, Any]:
        # Store by id for constant-time lookups
        self._entrants = {e["id"]: e for e in entrants}
        return {"ok": True, "entrants": list(self._entrants.keys())}

    def assign_tag(self, entrant_id: int, tag: Optional[str]) -> Dict[str, Any]:
        if entrant_id not in self._entrants:
            # We deliberately raise to let the API return 412 Precondition Failed
            raise KeyError("entrant not in active session")
        self._entrants[entrant_id]["tag"] = tag
        return {"ok": True, "entrant_id": entrant_id, "tag": tag}

ENGINE = _Engine()

# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------
async def _fetch_one(db: aiosqlite.Connection, sql: str, params: tuple = ()) -> Optional[aiosqlite.Row]:
    cur = await db.execute(sql, params)
    row = await cur.fetchone()
    await cur.close()
    return row

async def _exec(db: aiosqlite.Connection, sql: str, params: tuple = ()) -> None:
    await db.execute(sql, params)
    await db.commit()

def _normalize_tag(raw: Any) -> Optional[str]:
    """
    Normalize incoming tag payload:
      - None or whitespace-only -> None (clears the tag)
      - Else -> stripped string
    """
    if raw is None:
        return None
    s = str(raw).strip()
    return s or None

# ------------------------------------------------------------
# Race Modes YAML (for UI consumption)
# ------------------------------------------------------------
def _load_modes_file() -> dict:
    try:
        data = yaml.safe_load(MODES_PATH.read_text(encoding="utf-8")) or {}
    except FileNotFoundError:
        return {}
    # tolerate either {"modes": {...}} or a bare mapping
    return data.get("modes", data)

def _save_modes_file(modes: dict) -> None:
    MODES_PATH.parent.mkdir(parents=True, exist_ok=True)
    MODES_PATH.write_text(
        yaml.safe_dump({"modes": modes}, allow_unicode=True, sort_keys=True),
        encoding="utf-8",
    )

class ModeUpsert(BaseModel):
    id: str
    mode: dict

# ---------------- Race setup: modes ----------------

@app.get("/setup/race_modes")
def get_race_modes():
    """Return built-in modes for Race Setup, read from root/config/race_modes.yaml."""
    return {"modes": _load_modes_file()}

@app.post("/setup/race_modes/save")
def save_race_mode(payload: ModeUpsert):
    """Upsert a single mode in root/config/race_modes.yaml (used by 'Custom → Save Mode')."""
    modes = _load_modes_file()
    modes[payload.id] = payload.mode
    _save_modes_file(modes)
    return {"ok": True, "id": payload.id}

# --------------- Readiness compatibility (UI pings these) ---------------

@app.get("/health")
def health_alias():
    # UI expects /health; you also expose /healthz and /readyz.
    return {"status": "ok", "service": "ccrs-backend"}

@app.get("/admin/entrants/enabled_count")
async def entrants_enabled_count():
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT COUNT(*) FROM entrants WHERE enabled=1")
        row = await cur.fetchone()
        await cur.close()
        return {"count": int(row[0] if row and row[0] is not None else 0)}

@app.get("/decoders/status")
def decoders_status_stub():
    # Replace with real decoder detection when available.
    return {"online": 0}


# ------------------------------------------------------------
# Endpoints
# ------------------------------------------------------------
@app.post("/engine/load")
async def engine_load(payload: Dict[str, Any]):
    """
    Load the current runtime session with the given entrants list.
    Validation rules (hard 400s):
      - payload.race_id must be present and int-able.
      - payload.entrants must be a list.
      - each entrant must be an object with an 'id' that is int-able.
    We coerce id to int **before** any further mapping.
    """
    race_id = payload.get("race_id")
    if race_id is None:
        raise HTTPException(status_code=400, detail="missing required field: race_id")
    try:
        int(race_id)
    except Exception:
        raise HTTPException(status_code=400, detail=f"invalid race_id: {race_id!r}")

    entrants_ui = payload.get("entrants", []) or []
    if not isinstance(entrants_ui, list):
        raise HTTPException(status_code=400, detail="entrants must be a list")

    # Validate + coerce ids in place
    for idx, item in enumerate(entrants_ui):
        if not isinstance(item, dict):
            raise HTTPException(status_code=400, detail=f"entrant at index {idx} must be an object")
        if item.get("id") is None:
            raise HTTPException(status_code=400, detail=f"entrant at index {idx} missing id")
        try:
            item["id"] = int(item["id"])
        except Exception:
            raise HTTPException(status_code=400, detail=f"invalid entrant id at index {idx}: {item.get('id')!r}")

    # Minimal shape that the runtime uses (pass-through tolerated)
    entrants_engine: List[Dict[str, Any]] = []
    for item in entrants_ui:
        entrants_engine.append({
            "id": item["id"],
            "name": item.get("name"),
            "number": item.get("number"),
            "tag": _normalize_tag(item.get("tag")),
            "enabled": bool(item.get("enabled", True)),
        })

    snapshot = ENGINE.load(entrants_engine)
    return JSONResponse(snapshot)

@app.post("/engine/entrant/assign_tag")
async def engine_entrant_assign_tag(payload: Dict[str, Any]):
    """
    Idempotently assign (or clear) a transponder tag for a specific entrant.
    Guarantees:
      - Same tag to same entrant => 200 (no-op, still mirrored to Engine).
      - Conflicts consider ONLY enabled entrants and exclude the incumbent.
      - On change, writes through to DB.
      - If the entrant isn't in the active session, 412 Precondition Failed.
    """
    entrant_id = payload.get("entrant_id")
    if entrant_id is None:
        raise HTTPException(status_code=400, detail="missing required field: entrant_id")
    try:
        entrant_id = int(entrant_id)
    except Exception:
        raise HTTPException(status_code=400, detail=f"invalid entrant_id: {payload.get('entrant_id')!r}")

    tag = _normalize_tag(payload.get("tag"))

    async with aiosqlite.connect(DB_PATH) as db:
        # Fetch current row to compute idempotence and to confirm existence
        row = await _fetch_one(db, "SELECT enabled, tag FROM entrants WHERE entrant_id=?", (entrant_id,))
        if not row:
            raise HTTPException(status_code=404, detail=f"entrant {entrant_id} not found")
        enabled_db, tag_db = row[0], row[1]

        # Idempotent fast-path: nothing to change, but keep Engine in sync
        if tag_db == tag:
            try:
                snap = ENGINE.assign_tag(entrant_id, tag)
            except KeyError:
                raise HTTPException(status_code=412, detail="Entrant not in active session; reload roster via /engine/load")
            return JSONResponse(snap or {"ok": True})

        # Conflict check across ENABLED entrants, excluding this entrant
        if tag:
            # Use a short-lived sync connection for the helper (clean and clear).
            with sqlite3.connect(DB_PATH) as sconn:
                if tag_conflicts(sconn, tag, incumbent_entrant_id=entrant_id):
                    raise HTTPException(status_code=409, detail="Tag already assigned to another enabled entrant")

        # Update Engine first so UI reflects the new tag immediately
        try:
            snap = ENGINE.assign_tag(entrant_id, tag)
        except KeyError:
            raise HTTPException(status_code=412, detail="Entrant not in active session; reload roster via /engine/load")

        # Write-through to DB (NULL when clearing)
        await _exec(db,
                    "UPDATE entrants SET tag=?, updated_at=strftime('%s','now') WHERE entrant_id=?",
                    (tag, entrant_id))

    return JSONResponse(snap or {"ok": True})


# ------------------------------------------------------------
# Admin Entrants (authoritative DB read/write)
# ------------------------------------------------------------

from typing import Optional, Dict, Any
from pydantic import BaseModel, Field, ValidationError, field_validator
from fastapi import HTTPException
import aiosqlite
import sqlite3

# If not already imported somewhere above:
# from backend.db_schema import tag_conflicts  # adjust import path if needed

class EntrantIn(BaseModel):
    """
    Authoritative entrant record for the database.

    Semantics:
      - 'id': None or <= 0  => CREATE (SQLite assigns primary key)
              > 0           => UPDATE that row
      - 'number': coerced to string (accepts int or str)
      - 'tag': empty/whitespace becomes None; conflicts apply only when enabled==True and tag is not None
      - 'enabled': coerced to bool (accepts 1/0, "1"/"0", true/false)
    """
    id: Optional[int] = Field(default=None, description="entrant_id primary key; None/<=0 means create")

    number: Optional[str] = None
    name: str
    tag: Optional[str] = None
    enabled: bool = True
    status: str = "ACTIVE"

    # NEW: extra fields we actually want to persist
    organization: Optional[str] = ""
    spoken_name: Optional[str] = ""
    color: Optional[str] = None

    # ---- Normalizers / Coercions ----------------------------------------------------
    @field_validator('number', mode='before')
    @classmethod
    def _coerce_number(cls, v):
        if v is None:
            return None
        return str(v)

    @field_validator('tag', mode='before')
    @classmethod
    def _normalize_tag(cls, v):
        """
        Empty/whitespace-only tags become None so they don't participate
        in the unique-when-enabled rule.
        """
        if v is None:
            return None
        s = str(v).strip()
        return s or None


    @field_validator('enabled', mode='before')
    @classmethod
    def _coerce_enabled(cls, v):
        if isinstance(v, bool):
            return v
        if isinstance(v, int):
            return v == 1
        if isinstance(v, str):
            sv = v.strip().lower()
            if sv in ('1', 'true', 'yes', 'y', 'on'):
                return True
            if sv in ('0', 'false', 'no', 'n', 'off'):
                return False
        return bool(v)

    def is_create(self) -> bool:
        return self.id is None or (isinstance(self.id, int) and self.id <= 0)


def _norm_tag(value: Optional[str]) -> Optional[str]:
    if value is None:
        return None
    s = str(value).strip()
    return s or None


@app.get("/admin/entrants")
async def admin_list_entrants():
    """
    Authoritative read of entrants for Operator UI.
    """
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cur = await db.execute("""
            SELECT
              entrant_id AS id,
              number, name, tag, enabled,
              status, organization, spoken_name, color,
              logo, updated_at
            FROM entrants
            ORDER BY CAST(number AS INTEGER) NULLS LAST, name
        """)
        rows = await cur.fetchall()
        await cur.close()

        out = []
        for r in rows:
            out.append({
                "id": int(r["id"]) if r["id"] is not None else None,
                "number": (str(r["number"]) if r["number"] is not None else None),
                "name": r["name"],
                "tag": r["tag"],
                "enabled": bool(r["enabled"]),
                "status": r["status"],
                "organization": r["organization"],
                "spoken_name": r["spoken_name"],
                "color": r["color"],
                "logo": r["logo"],
                "updated_at": r["updated_at"],
            })
        return out


@app.post("/admin/entrants")
async def admin_upsert_entrants(payload: Dict[str, Any]):
    """
    Create or update entrants in the authoritative DB.

    Rules:
      • Among ENABLED entrants only, 'tag' must be unique.
      • Atomic batch in a single transaction.
      • Returns 409 on conflict, 400 on bad payload, 200 on success.
    """
    entrants = payload.get("entrants")
    if not isinstance(entrants, list):
        raise HTTPException(status_code=400, detail="body must contain 'entrants' as a list")

    # 1) Validate/normalize
    entries: list[EntrantIn] = []
    for idx, item in enumerate(entrants):
        if not isinstance(item, dict):
            raise HTTPException(status_code=400, detail=f"entrant at index {idx} must be an object")
        try:
            e = EntrantIn(**item)
        except ValidationError as ve:
            raise HTTPException(status_code=400, detail=f"invalid entrant at index {idx}: {ve.errors()!r}")
        entries.append(e)

    # 2) Transaction + uniqueness guard
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("BEGIN IMMEDIATE")
        try:
            # App-level duplicate tag check (enabled & tag not null)
            with sqlite3.connect(DB_PATH) as sconn:
                for e in entries:
                    if e.enabled and e.tag:
                        if tag_conflicts(sconn, e.tag, incumbent_entrant_id=(None if e.is_create() else e.id)):
                            await db.execute("ROLLBACK")
                            raise HTTPException(
                                status_code=409,
                                detail=f"tag '{e.tag}' already assigned to another enabled entrant (while upserting id={e.id or 'new'})"
                            )

            created = 0
            updated = 0
            assigned_ids: list[dict] = []

            for i, e in enumerate(entries):
                tag_value = _norm_tag(e.tag)

                if e.is_create():
                    # -------- INSERT (let SQLite assign entrant_id) --------
                    cur = await db.execute(
                        """
                        INSERT INTO entrants
                          (number, name, tag, enabled, status, organization, spoken_name, color, updated_at)
                        VALUES
                          (?,      ?,    ?,   ?,       ?,      ?,            ?,           ?,     strftime('%s','now'))
                        """,
                        (
                            e.number,
                            e.name,
                            tag_value,
                            1 if e.enabled else 0,
                            e.status,
                            e.organization or "",
                            e.spoken_name or "",
                            e.color,
                        ),
                    )
                    new_id = cur.lastrowid
                    assigned_ids.append({"client_idx": i, "id": new_id})
                    await cur.close()
                    created += 1
                else:
                    # -------- UPSERT by PRIMARY KEY --------
                    await db.execute(
                        """
                        INSERT INTO entrants
                          (entrant_id, number, name, tag, enabled, status, organization, spoken_name, color, updated_at)
                        VALUES
                          (?,          ?,      ?,    ?,   ?,       ?,      ?,            ?,           ?,     strftime('%s','now'))
                        ON CONFLICT(entrant_id) DO UPDATE SET
                          number       = excluded.number,
                          name         = excluded.name,
                          tag          = excluded.tag,
                          enabled      = excluded.enabled,
                          status       = excluded.status,
                          organization = excluded.organization,
                          spoken_name  = excluded.spoken_name,
                          color        = excluded.color,
                          updated_at   = strftime('%s','now')
                        """,
                        (
                            e.id,
                            e.number,
                            e.name,
                            tag_value,
                            1 if e.enabled else 0,
                            e.status,
                            e.organization or "",
                            e.spoken_name or "",
                            e.color,
                        ),
                    )
                    updated += 1

            await db.commit()
            return {
                "ok": True,
                "count": created + updated,
                "created": created,
                "updated": updated,
                "assigned_ids": assigned_ids,
            }

        except HTTPException:
            raise
        except sqlite3.IntegrityError as ie:
            await db.execute("ROLLBACK")
            raise HTTPException(status_code=409, detail=f"uniqueness violation: {ie}")
        except Exception as ex:
            await db.execute("ROLLBACK")
            raise HTTPException(status_code=500, detail=f"admin upsert failed: {type(ex).__name__}: {ex}")



# ------------------------------------------------------------
# Delete Preflight does this entrant have data linked?
# ------------------------------------------------------------

@app.get("/admin/entrants/{entrant_id}/inuse")
async def entrant_inuse(entrant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row

        # 1) Identity (404 if missing)
        cur = await db.execute(
            "SELECT entrant_id AS id, number, name FROM entrants WHERE entrant_id=?",
            (entrant_id,)
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            raise HTTPException(status_code=404, detail="entrant not found")

        # 2) Safe counters (return 0 if tables/cols not found or any other error)
        async def _count(tbl: str, col: str, val: int) -> int:
            try:
                c = await db.execute(f"SELECT COUNT(*) FROM {tbl} WHERE {col}=?", (val,))
                r = await c.fetchone()
                await c.close()
                return int(r[0] if r and r[0] is not None else 0)
            except Exception as ex:
                # Log to server console; never bubble to client
                print(f"[inuse] count failed for {tbl}.{col}={val}: {type(ex).__name__}: {ex}")
                return 0

        passes_cnt = await _count("passes", "entrant_id", entrant_id)
        laps_cnt   = await _count("lap_events", "entrant_id", entrant_id)

        return {
            "id": row["id"],
            "number": row["number"],
            "name": row["name"],
            "counts": { "passes": passes_cnt, "lap_events": laps_cnt }
        }



# ======================= DELETE (hard delete by id) =======================

@app.post("/admin/entrants/delete")
async def delete_entrant(request: Request):
    try:
        payload = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="invalid JSON body")

    # Accept either { id } or { ids: [...] }
    ids = payload.get("ids")
    if ids is None:
        one = payload.get("id")
        if one is None:
            raise HTTPException(status_code=400, detail="missing 'id' (or 'ids')")
        ids = [one]

    # Coerce to ints and dedupe
    try:
        ids = [int(x) for x in ids]
    except Exception:
        raise HTTPException(status_code=400, detail="ids must be integers")

    if not ids:
        raise HTTPException(status_code=400, detail="no ids provided")

    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("BEGIN IMMEDIATE")
        try:
            deleted = []
            for eid in ids:
                await db.execute("DELETE FROM entrants WHERE entrant_id=?", (eid,))
                ch = await (await db.execute("SELECT changes()")).fetchone()
                if ch and ch[0] > 0:
                    deleted.append(eid)
            await db.commit()
        except Exception as ex:
            await db.execute("ROLLBACK")
            raise HTTPException(status_code=500, detail=f"delete failed: {type(ex).__name__}: {ex}")

    if not deleted:
        raise HTTPException(status_code=404, detail="entrant not found")

    return {"deleted": deleted}






# ------------------------------------------------------------
# Polling endpoint (UI fallback)
# ------------------------------------------------------------

@app.get("/ilap/peek")
async def ilap_peek():
    """Return the last observed tag. UI de-duplicates via seen_at."""
    return JSONResponse(last_tag)


# ------------------------------------------------------------
# SSE endpoint (preferred by UI)
# ------------------------------------------------------------

@app.get("/ilap/stream")
async def ilap_stream(request: Request):
    """Send exactly one tag event and then end (UI opens per-scan)."""
    q: asyncio.Queue[str] = asyncio.Queue()
    _listeners.append(q)

    async def gen():
        try:
            # If client disconnects or cancels scan, this raises
            tag = await asyncio.wait_for(q.get(), timeout=10.0)
            payload = json.dumps({"tag": str(tag)})
            yield f"event: tag\ndata: {payload}\n\n"
        except asyncio.TimeoutError:
            # No tag within window → end quietly (UI shows timeout)
            return
        finally:
            if q in _listeners:
                _listeners.remove(q)

    # Note: the UI preflights this; returning stream only if used
    return StreamingResponse(gen(), media_type="text/event-stream")

# External publishers via CURL
@app.post("/ilap/inject")
async def ilap_inject(tag: str):
    """Convenience endpoint so external processes can push tags."""
    ts = publish_tag(tag)
    return {"ok": True, "seen_at": ts}
#

# --- Embedded scanner startup: publish via HTTP to our own FastAPI ---
@app.on_event("startup")
async def start_scanner():
    """
    Start the ScannerService but publish laps via HTTP into this server,
    avoiding the in-process publisher hook and any circular imports.
    """
    from backend.lap_logger import ScannerService, load_config

    # Load your runtime config (we only need it to exist & parse)
    cfg = load_config("./config/ccrs.yaml")

    # Force HTTP publishing so the scanner POSTs laps to our endpoint.
    # Different builds of ScannerService may look for slightly different keys;
    # we set the common ones so whichever exists gets used.
    cfg.publisher.mode = "http"
    # Most implementations use one of these:
    setattr(cfg.publisher, "url", "http://127.0.0.1:8000/ilap/inject")
    setattr(cfg.publisher, "endpoint", "http://127.0.0.1:8000/ilap/inject")
    # If there is a nested HTTP config object, prime it too (harmless if absent):
    if not hasattr(cfg.publisher, "http"):
        setattr(cfg.publisher, "http", type("HttpCfg", (), {})())
    setattr(cfg.publisher.http, "url", "http://127.0.0.1:8000/ilap/inject")
    setattr(cfg.publisher.http, "timeout_s", 2.0)

    # Spin up the scanner task
    app.state.stop_evt = asyncio.Event()
    app.state.task = asyncio.create_task(ScannerService(cfg).run(app.state.stop_evt))


@app.on_event("shutdown")
async def stop_scanner():
    """
    Gracefully stop the background scanner on shutdown.
    """
    stop_evt = getattr(app.state, "stop_evt", None)
    task = getattr(app.state, "task", None)
    if stop_evt:
        stop_evt.set()
    if task:
        try:
            await task
        except Exception:
            pass


# ==============================================================================
# Diagnostics / Live Sensors - SSE stream for diag.html
# ==============================================================================

    
# In-memory pub/sub state
DIAGNOSTICS_ENABLED: bool = True
DIAGNOSTICS_BUFFER_SIZE: int = 500
_diag_ring = deque(maxlen=DIAGNOSTICS_BUFFER_SIZE)
_diag_subs: set[asyncio.Queue] = set()
_diag_lock = asyncio.Lock()

async def diag_publish(evt: dict) -> None:
    """Publish a detection event to all diagnostics subscribers."""
    if not DIAGNOSTICS_ENABLED:
        return
    if "time" not in evt:
        evt = dict(evt)
        evt["time"] = datetime.datetime.now(datetime.timezone.utc)\
            .isoformat(timespec="milliseconds").replace("+00:00", "Z")
    _diag_ring.append(evt)
    async with _diag_lock:
        dead = []
        for q in _diag_subs:
            try:
                q.put_nowait(evt)
            except asyncio.QueueFull:
                try:
                    _ = q.get_nowait()
                    q.put_nowait(evt)
                except Exception:
                    dead.append(q)
        for q in dead:
            _diag_subs.discard(q)

@app.get("/diagnostics/stream")
async def diagnostics_stream(request: Request):
    """EventSource stream for diagnostics/live sensors."""
    if not DIAGNOSTICS_ENABLED:
        async def disabled_gen():
            yield b'data: {"type":"status","message":"diagnostics_disabled"}\n\n'
        return StreamingResponse(disabled_gen(), media_type="text/event-stream")

    q = asyncio.Queue(maxsize=1024)
    async with _diag_lock:
        _diag_subs.add(q)

    async def gen():
        try:
            for evt in list(_diag_ring):
                if await request.is_disconnected():
                    break
                yield f"data: {json.dumps(evt, separators=(',',':'))}\n\n".encode()
            while not await request.is_disconnected():
                evt = await q.get()
                yield f"data: {json.dumps(evt, separators=(',',':'))}\n\n".encode()
        finally:
            async with _diag_lock:
                _diag_subs.discard(q)

    return StreamingResponse(gen(), media_type="text/event-stream", headers={"Cache-Control": "no-store"})

@app.post("/diagnostics/test_fire")
async def diagnostics_test_fire():
    """Inject a dummy detection for testing the diag.html frontend."""
    evt = {
        "tag_id": "1234567",
        "entrant": {"name": "Thunder Lizards", "number": "42"},
        "source": "Start/Finish",
        "rssi": -63,
    }
    await diag_publish(evt)
    return {"ok": True, "sent": evt}

# Minimal runtime stub for frontends (Settings/Diagnostics)
@app.get("/setup/runtime")
async def setup_runtime():
    return {
        "engine": {
            "ingest": {"debounce_ms": 250},
            "diagnostics": {
                "enabled": True,
                "buffer_size": 500,
                "stream": {"transport": "sse"},
                "beep": {"max_per_sec": 5},
            },
        },
        "race": {
            "flags": {"inference_blocklist": ["YELLOW", "RED", "SC"], "post_green_grace_ms": 3000},
            "missed_lap": {"enabled": False, "apply_mode": "propose", "window_laps": 5, "sigma_k": 2.0,
                        "min_gap_ms": 8000, "max_consecutive_inferred": 1, "mark_inferred": True},
        },
        "track": {"locations": {"SF": "Start/Finish", "PIT_IN": "Pit In", "PIT_OUT": "Pit Out"}, "bindings": []},
        "ui": {"operator": {"sound_default_enabled": True, "time_display": "local"}},
        "meta": {"engine_host": "127.0.0.1:8000"},
    }


# ------------------------------------------------------------
# Probes
# ------------------------------------------------------------
@app.get("/healthz")
async def healthz():
    """
    Lightweight liveness probe. Returns 200 if the app is up and able to serve.
    Does not touch the database.
    """
    return {"status": "ok", "service": "ccrs-backend"}

@app.get("/readyz")
async def readyz():
    """
    Readiness probe. Verifies DB is reachable and schema is present.
    Returns 200 with basic info if good; 503 if DB check fails.
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            # succeeds only if 'entrants' exists
            await db.execute("SELECT 1 FROM entrants LIMIT 1")
        return {"status": "ok", "db_path": str(DB_PATH)}
    except Exception as e:
        return Response(
            content='{"status":"degraded","error":"%s"}' % type(e).__name__,
            media_type="application/json",
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
        )
