<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CCRS — Settings</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- =====================================================================
       SETTINGS PAGE OVERVIEW
       ---------------------------------------------------------------------
       This HTML page defines the Operator Settings screen for the CCRS
       Operator interface. It provides a two-column layout (side navigation
       + main content) and fixed header/footer sized for 1920×1080 displays.

       The intent is to give operators full visibility and control over
       runtime configuration parameters — including diagnostics, debounce,
       flags, missed-lap detection, etc. Each control here will eventually
       map to runtime configuration endpoints in the backend.
  ===================================================================== -->

  <!-- Shared foundation stylesheets -->
  <link rel="stylesheet" href="../css/base.css" />
  <link rel="stylesheet" href="../css/operator.css" />

  <!-- Page-specific stylesheet for Settings -->
  <link rel="stylesheet" href="../css/settings.css" />

  <!-- Base helper script for global functions (CCRS namespace) -->
  <script src="../js/base.js" defer></script>
</head>
<body class="page settings">
  <!-- =====================================================================
       HEADER SECTION (fixed)
       ---------------------------------------------------------------------
       Includes the CCRS branding, current engine status label, and serves
       as an always-visible navigation anchor.
  ===================================================================== -->
  <header class="app-header">
    <div class="brand">
      <img class="brand-logo" src="../img/CCRS_Logo.svg" alt="ChronoCore Logo">
      <div class="brand__wordmark" aria-label="ChronoCore Race Software">
        <div class="wordmark__top">
          <span class="wordmark__big">CHRONO</span>
          <span class="wordmark__big">CORE</span>
        </div>
        <div class="wordmark__bottom">RACE SOFTWARE</div>
      </div>
      <div class="page-label">Settings</div>
    </div>

    <div class="app-header__tools">
      <div class="pill" id="engineLabel">Engine: —</div>
    </div>
  </header>

  <!-- =====================================================================
       MAIN LAYOUT (two columns)
       ---------------------------------------------------------------------
       Left column: sticky navigation.
       Right column: scrollable cards for each configuration section.
  ===================================================================== -->
  <main class="settingsWrap">
    <nav class="sideNav" aria-label="Settings sections">
      <a href="#client" class="navLink">Client Role</a>
      <a href="#engine" class="navLink">Engine Host</a>
      <a href="#ingest" class="navLink">Ingest & Debounce</a>
      <a href="#diagnostics" class="navLink">Diagnostics</a>
      <a href="#track" class="navLink">Track Locations & Bindings</a>
      <a href="#flags" class="navLink">Flags</a>
      <a href="#missed" class="navLink">Missed-Lap Detection</a>
      <a href="#ui" class="navLink">UI & Audio</a>

      <div class="navSep" role="separator" aria-hidden="true"></div>


      <a href="#apply" class="navLink navLink--primary">Apply / Save</a>
    </nav>

    <div class="pane pane--right">
      <div class="pane__scroll">
        <section id="client" class="card"><h2>Client Role</h2></section>
        <section id="engine" class="card"><h2>Engine Host</h2></section>
        <section id="ingest" class="card"><h2>Ingest & Debounce</h2></section>
        <section id="diagnostics" class="card"><h2>Diagnostics</h2></section>
        <section id="track" class="card"><h2>Track Locations & Bindings</h2></section>
        <section id="flags" class="card"><h2>Flags</h2></section>
        <section id="missed" class="card"><h2>Missed-Lap Detection</h2></section>
        <section id="ui" class="card"><h2>UI & Audio</h2></section>
        <section id="apply" class="card"><h2>Apply / Save</h2></section>
      </div>
    </div>
  </main>

  <!-- =====================================================================
       FOOTER SECTION (fixed)
       ---------------------------------------------------------------------
       Displays connectivity and wall clock information for operator context.
  ===================================================================== -->

  <footer class="app-footer">
    <div class="footer-left">
      <div class="status-dot" id="netDot"></div>
      <div id="netMsg">Ready</div>
    </div>
    <div class="footer-right">
      <a class="link" href="/admin/setup" target="_blank" rel="noopener">GET /setup/runtime</a>
    </div>
  </footer>

  <!-- =====================================================================
       PAGE SCRIPT (basic wiring)
       ---------------------------------------------------------------------
       Connects DOM elements, populates fields, and hooks into base.js.
       This script will eventually fetch the runtime snapshot and enable
       saving or hot-applying configuration updates.
  ===================================================================== -->
  <script>
    (function () {
      'use strict';

      // CCRS namespace + tiny qs helper (keep these)
      const CCRS = window.CCRS || {};
      const $ = (sel, root) => (root || document).querySelector(sel);

      // Collect important elements (your existing, robust version)
      const ids = [
        'role','saveRole','policySummary','effectiveHost','engineOverride','overrideHelp',
        'testEngine','saveEngine','clearEngine','engineMsg','engineLabel',
        'debounce','debounceOverrides','minLapMs',
        'diagEnabled','diagBuffer','diagTransport','beepMax','testBeep',
        'locList','bindList','flagBlock','flagGrace',
        'missedMode','missedWindow','missedK','missedMinGap','missedMaxSeq','missedMark',
        'soundDefault','timeDisplay','configDiff','applyHot','applyRestart','revert','applyMsg'
      ];
      const el = ids.reduce((acc, id) => {
        if (typeof id !== 'string' || !id.trim()) return acc;   // skip holes/comments
        acc[id] = document.getElementById(id) || null;
        return acc;
      }, {});

      document.addEventListener('DOMContentLoaded', init);

      function init() {
        // Optional engine label
        if (typeof CCRS.effectiveEngineLabel === 'function' && el.engineLabel) {
          el.engineLabel.textContent = 'Engine: ' + CCRS.effectiveEngineLabel();
        }
        // Wire left nav (anchors → internal scroller + highlight)
        enableLeftNav();
      }

      function enableLeftNav() {
        const scroller = document.querySelector('.pane__scroll');
        if (!scroller) return;

        const links = Array.from(document.querySelectorAll('.sideNav .navLink[href^="#"]'));
        const sections = links
          .map(a => document.querySelector(a.getAttribute('href')))
          .filter(Boolean);

        // Immediate visual feedback on click + smooth scroll inside the pane
        links.forEach(a => {
          a.addEventListener('click', (e) => {
            e.preventDefault();
            const sel = a.getAttribute('href');
            const target = document.querySelector(sel);
            if (!target) return;

            // Make clicked link active right away
            links.forEach(l => l.classList.remove('active'));
            a.classList.add('active');

            // Compute target offset relative to the internal scroller
            const top = target.getBoundingClientRect().top
                      - scroller.getBoundingClientRect().top
                      + scroller.scrollTop
                      - 8; // tiny breathing room below the sticky h2
            scroller.scrollTo({ top, behavior: 'smooth' });
          });
        });

        // Scrollspy: keep active link in sync as you scroll the pane
        if (sections.length) {
          const linkById = Object.fromEntries(
            links.map(l => [l.getAttribute('href'), l])
          );

          const io = new IntersectionObserver((entries) => {
            // choose the most-visible section
            let best = null, max = 0;
            for (const e of entries) {
              if (e.intersectionRatio >= max) {
                max = e.intersectionRatio;
                best = e.target;
              }
            }
            if (!best) return;
            links.forEach(l => l.classList.remove('active'));
            const hit = linkById['#' + best.id];
            if (hit) hit.classList.add('active');
          }, {
            root: scroller,
            threshold: [0.35, 0.55, 0.75]
          });

          sections.forEach(sec => io.observe(sec));
        }
      }
    })();
    </script>

</body>
</html>